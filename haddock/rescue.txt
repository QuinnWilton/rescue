-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | More understandable exceptions
--   
--   An error handling library focused on clarity and control
@package rescue
@version 0.3.0


-- | Common exceptions
module Data.Exception.Types
data NotFound entity
NotFound :: NotFound entity
data NotAllowed entity user
NotAllowed :: entity -> user -> NotAllowed entity user
newtype AlreadyExists entity
AlreadyExists :: entity -> AlreadyExists entity
newtype OutOfBounds entity index
OutOfBounds :: index -> OutOfBounds entity index
data DivideByZero
DivideByZero :: DivideByZero
instance GHC.Classes.Eq err => GHC.Classes.Eq (Data.Exception.Types.WithMessage err)
instance GHC.Show.Show err => GHC.Show.Show (Data.Exception.Types.WithMessage err)
instance GHC.Classes.Eq entity => GHC.Classes.Eq (Data.Exception.Types.InvalidFormat entity)
instance GHC.Show.Show entity => GHC.Show.Show (Data.Exception.Types.InvalidFormat entity)
instance GHC.Classes.Eq Data.Exception.Types.DivideByZero
instance GHC.Show.Show Data.Exception.Types.DivideByZero
instance GHC.Classes.Eq index => GHC.Classes.Eq (Data.Exception.Types.OutOfBounds entity index)
instance GHC.Show.Show index => GHC.Show.Show (Data.Exception.Types.OutOfBounds entity index)
instance GHC.Classes.Eq entity => GHC.Classes.Eq (Data.Exception.Types.AlreadyExists entity)
instance GHC.Show.Show entity => GHC.Show.Show (Data.Exception.Types.AlreadyExists entity)
instance (GHC.Classes.Eq entity, GHC.Classes.Eq user) => GHC.Classes.Eq (Data.Exception.Types.NotAllowed entity user)
instance (GHC.Show.Show entity, GHC.Show.Show user) => GHC.Show.Show (Data.Exception.Types.NotAllowed entity user)
instance GHC.Classes.Eq (Data.Exception.Types.NotFound entity)
instance GHC.Show.Show (Data.Exception.Types.NotFound entity)

module Data.Result.Types

-- | <a>Result</a> is a synonym for 'Either (OpenUnion errs) a'
type Result (errs :: [Type]) = Either (OpenUnion errs)
pattern Ok :: val -> Either (OpenUnion err) val
pattern Err :: OpenUnion errs -> Either (OpenUnion errs) b

module Data.WorldPeace.IsOpenUnion.Family

-- | Type-level check that a type is an open union. For use with the
--   <tt>Subset'</tt> typeclass.
type family IsOpenUnion a :: Bool

module Data.WorldPeace.Subset.Class.Internal

-- | Hack around overlapping instances to check subsets of bare values or
--   <a>OpenUnion</a>s automatically
class Subset' (flag :: Bool) (err :: Type) (errs :: [Type])
include' :: Subset' flag err errs => Proxy flag -> err -> OpenUnion errs
instance Data.WorldPeace.Union.Contains err errs => Data.WorldPeace.Subset.Class.Internal.Subset' 'GHC.Types.True (Data.WorldPeace.Union.OpenUnion err) errs
instance Data.WorldPeace.Union.IsMember err errs => Data.WorldPeace.Subset.Class.Internal.Subset' 'GHC.Types.False err errs

module Data.WorldPeace.Subset.Class

-- | State that some type <tt>err</tt> is a subset of <tt>errs</tt>
--   
--   In essence, this is used to avoid having to specially lift bare values
--   to an <a>OpenUnion</a>. We can treat all types and <a>OpenUnion</a>s
--   the same.
class Subset err errs
include :: Subset err errs => err -> errs
instance (Data.WorldPeace.IsOpenUnion.Family.IsOpenUnion err GHC.Types.~ flag, Data.WorldPeace.Subset.Class.Internal.Subset' flag err errs) => Data.WorldPeace.Subset.Class.Subset err (Data.WorldPeace.Union.OpenUnion errs)


-- | The <a>MonadRaise</a> class, which is an effect for early escape /
--   happy path programming with an exception side channel
module Control.Monad.Raise.Class

-- | Raise semantics, like a type-directed <tt>MonadThrow</tt>. Not unlike
--   <tt>MonadError</tt> with an in-built open variant.
class Monad m => MonadRaise m where {
    type family Errors m :: [Type];
}

-- | Raise an error
--   
--   The <tt>Proxy</tt> gives a type hint to the type checker. If you have
--   a case where it can be inferred, see <a>raise'</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; data FooErr  = FooErr  deriving Show
--   
--   &gt;&gt;&gt; data BarErr  = BarErr  deriving Show
--   
--   &gt;&gt;&gt; data QuuxErr = QuuxErr deriving Show
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; type MyErrs  = '[FooErr, BarErr]
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; :{
--    goesBoom :: Int -&gt; Either (OpenUnion MyErrs) Int
--    goesBoom x =
--      if x &gt; 50
--        then return x
--        else raise FooErr
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; goesBoom 42
--   Left (Identity FooErr)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    maybeBoom :: Int -&gt; Maybe Int
--    maybeBoom x =
--      if x &gt; 50
--        then return x
--        else raise ()
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeBoom 42
--   Nothing
--   </pre>
raise :: (MonadRaise m, Subset err (ErrorCase m)) => err -> m a

-- | Type alias representing the concrete union of the monad's errors
type ErrorCase m = OpenUnion (Errors m)
instance Control.Monad.Raise.Class.MonadRaise []
instance Control.Monad.Raise.Class.MonadRaise GHC.Maybe.Maybe
instance Control.Monad.Raise.Class.MonadRaise (Data.Either.Either (Data.WorldPeace.Union.OpenUnion errs))
instance Control.Monad.Raise.Class.MonadRaise GHC.Types.IO
instance Control.Monad.Raise.Class.MonadRaise (GHC.ST.ST s)
instance Control.Monad.Raise.Class.MonadRaise GHC.Conc.Sync.STM
instance (Control.Monad.Raise.Class.MonadRaise m, Data.WorldPeace.Union.Contains (Control.Monad.Raise.Class.Errors m) errs) => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Except.ExceptT (Data.WorldPeace.Union.OpenUnion errs) m)
instance Control.Monad.Raise.Class.MonadRaise m => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Identity.IdentityT m)
instance (Data.WorldPeace.Union.IsMember () (Control.Monad.Raise.Class.Errors m), Control.Monad.Raise.Class.MonadRaise m) => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Raise.Class.MonadRaise m => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Reader.ReaderT cfg m)
instance Control.Monad.Raise.Class.MonadRaise m => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Catch.Pure.CatchT m)
instance Control.Monad.Raise.Class.MonadRaise m => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Raise.Class.MonadRaise m => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Raise.Class.MonadRaise m => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.State.Strict.StateT s m)
instance (Control.Monad.Raise.Class.MonadRaise m, GHC.Base.Monoid w) => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Raise.Class.MonadRaise m, GHC.Base.Monoid w) => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Control.Monad.Raise.Class.MonadRaise m, GHC.Base.Monoid w) => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Raise.Class.MonadRaise m, GHC.Base.Monoid w) => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.RWS.Strict.RWST r w s m)


-- | Declare which exceptions may be raised/rescued in a given context
module Control.Monad.Raise.Constraint

-- | Raises this exception, but potentially others
type Raises m err = Subset err (ErrorCase m)

-- | May raise errors, including the provided list
type RaisesAtLeast m errs = Subset (OpenUnion errs) (ErrorCase m)

-- | Restrict exceptions to exactly this list
type RaisesOnly m errs = errs ~ Errors m

-- | Raises an exception, guaranteed to NOT be the outer union
type RaisesOne m err = IsMember err (Errors m)


-- | Monadic raise semantics &amp; helpers
module Control.Monad.Raise

-- | Lift a pure error (<tt>Either</tt>) into a <tt>MonadRaise</tt> context
--   i.e. Turn <tt>Left</tt>s into <tt>raise</tt>s.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     mayFail :: Int -&gt; Either FooErr Int
--     mayFail n =
--       if n &gt; 50
--         then Left FooErr
--         else Right n
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     goesBoom :: (MonadRaise m, m `Raises` FooErr) =&gt; m Int
--     goesBoom = do
--       first  &lt;- ensure $ mayFail 100
--       second &lt;- ensure $ mayFail 42
--       return $ second * 10
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; goesBoom :: Result '[FooErr, BarErr] Int
--   Left (Identity FooErr)
--   </pre>
ensure :: (MonadRaise m, Raises m inner) => Either inner a -> m a

-- | A version of <tt>ensure</tt> that takes monadic actions
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     mayFailM :: Monad m =&gt; Int -&gt; m (Either (OpenUnion '[FooErr, BarErr]) Int)
--     mayFailM n =
--       return $ if n &gt; 50
--         then Left (openUnionLift FooErr)
--         else Right n
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     foo :: (MonadRaise m, RaisesOnly m '[FooErr, BarErr]) =&gt; m Int
--     foo = do
--       first  &lt;- ensureM $ mayFailM 100
--       second &lt;- ensureM $ mayFailM first
--       return (second * 10)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runRescue (foo :: Rescue '[FooErr, BarErr] Int)
--   Left (Identity FooErr)
--   </pre>
ensureM :: (MonadRaise m, Raises m inner) => m (Either inner a) -> m a

module Data.Result

-- | Upgrade from an <a>Either</a> to a <a>Result</a>
fromEither :: Subset err (OpenUnion errs) => Either err val -> Result errs val


-- | The <tt>MonadRescue</tt> class, meant for retrieving the
--   success/failure branches
module Control.Monad.Rescue.Class

-- | Pull a potential error out of the surrounding context NOTE that the
--   target <tt>m</tt> may not even be aware of Raise/Rescue. It's an
--   escape to the "normal" world
class (Monad m, MonadRaise n) => MonadRescueFrom n m

-- | Attempt some action, exposing the success and error branches
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     goesBoom :: Int -&gt; Rescue '[FooErr, BarErr] Int
--     goesBoom x =
--       if x &gt; 50
--         then return x
--         else raise FooErr
--    :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     result :: Identity (Either (OpenUnion '[FooErr, BarErr]) Int)
--     result = attempt $ goesBoom 42
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; result
--   Identity (Left (Identity FooErr))
--   </pre>
--   
--   Where <tt>Identity FooErr</tt> is the selection of the
--   <a>OpenUnion</a>.
attempt :: MonadRescueFrom n m => n a -> m (Either (ErrorCase n) a)
instance GHC.Base.Monad n => Control.Monad.Rescue.Class.MonadRescueFrom GHC.Maybe.Maybe n
instance GHC.Base.Monad m => Control.Monad.Rescue.Class.MonadRescueFrom [] m
instance GHC.Base.Monad m => Control.Monad.Rescue.Class.MonadRescueFrom (Data.Either.Either (Data.WorldPeace.Union.OpenUnion errs)) m
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.Rescue.Class.MonadRescueFrom GHC.Types.IO m
instance (GHC.Base.Monad m, Control.Monad.Rescue.Class.MonadRescueFrom n m, Control.Monad.Raise.Constraint.RaisesOne n ()) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Maybe.MaybeT n) m
instance Control.Monad.Rescue.Class.MonadRescueFrom n m => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Identity.IdentityT n) m
instance (Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n n, Data.WorldPeace.Union.Contains (Control.Monad.Raise.Class.Errors n) errs) => Control.Monad.Rescue.Class.MonadRescueFrom n (Control.Monad.Trans.Except.ExceptT (Data.WorldPeace.Union.OpenUnion errs) m)
instance (GHC.Base.Monad m, Control.Monad.Base.MonadBase n m, Control.Monad.Raise.Class.MonadRaise n, Control.Monad.Rescue.Class.MonadRescueFrom n m) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Reader.ReaderT cfg n) (Control.Monad.Trans.Reader.ReaderT cfg m)
instance (GHC.Base.Monad m, Control.Monad.Base.MonadBase n m, Control.Monad.Raise.Class.MonadRaise n, Control.Monad.Rescue.Class.MonadRescueFrom n n) => Control.Monad.Rescue.Class.MonadRescueFrom n (Control.Monad.Trans.Reader.ReaderT cfg m)
instance (GHC.Base.Monoid w, Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n m) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Writer.Lazy.WriterT w n) (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n n) => Control.Monad.Rescue.Class.MonadRescueFrom n (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n m) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Writer.Strict.WriterT w n) (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n n) => Control.Monad.Rescue.Class.MonadRescueFrom n (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n m) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.State.Lazy.StateT s n) (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n n) => Control.Monad.Rescue.Class.MonadRescueFrom n (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n m) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.State.Strict.StateT s n) (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n m) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.RWS.Lazy.RWST r w s n) (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n n) => Control.Monad.Rescue.Class.MonadRescueFrom n (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n n) => Control.Monad.Rescue.Class.MonadRescueFrom n (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Class.MonadRescueFrom n n) => Control.Monad.Rescue.Class.MonadRescueFrom n (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Cont.ContT r m) m => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Cont.ContT r m) (Control.Monad.Trans.Cont.ContT r m)

module Control.Monad.Rescue.Constraint

-- | Express the ability to <tt>handle</tt> / eliminate an exception case
type Handles err n m = (ElemRemove err (Errors n), Contains (Remove err (Errors n)) (Errors m))

-- | Rescue from the existing context only
--   
--   Note: cannot <tt>handle</tt> (elimininate) exceptions
type MonadRescue m = MonadRescueFrom m m


-- | Rescue semantics &amp; helpers
--   
--   Essentially a type-directed version of <a>Catch</a>.
--   
--   This is the opposite of <a>Raise</a>, which embeds en error.
--   <tt>Rescue</tt> takes a potential error out of the surrounding context
--   and either handles or exposes it.
module Control.Monad.Rescue

-- | Handle all exceptions
--   
--   <pre>
--   &gt;&gt;&gt; type MyErrs = '[FooErr, BarErr]
--   
--   &gt;&gt;&gt; myErrs = Proxy @MyErrs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   goesBoom :: Int -&gt; Rescue MyErrs String
--   goesBoom x =
--     if x &gt; 50
--       then return (show x)
--       else raise FooErr
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; handler = catchesOpenUnion (\foo -&gt; "Foo: " &lt;&gt; show foo, \bar -&gt; "Bar:" &lt;&gt; show bar)
--   
--   &gt;&gt;&gt; rescue (goesBoom 42) (pure . handler) :: Rescue MyErrs String
--   RescueT (Identity (Right "Foo: FooErr"))
--   </pre>
rescue :: MonadRescueFrom n m => n a -> (ErrorCase n -> m a) -> m a
handle :: (MonadRaise m, MonadRescueFrom n m, Handles err n m) => n a -> (err -> m a) -> m a

-- | <tt>retry</tt> without asynchoronous exception cleanup. Useful when
--   not dealing with external resources that may be dangerous to close
--   suddenly.
reattempt :: MonadRescue m => Natural -> m a -> m a
onRaise :: (MonadRescue m, RaisesOnly m errs) => (OpenUnion errs -> m ()) -> m a -> m (Result errs a)

-- | Run an additional step, and throw away the result. Return the result
--   of the action passed.
lastly :: (Errors m `Contains` Errors m, MonadRaise m, MonadRescueFrom m m) => m a -> m b -> m a


-- | The <a>RescueT</a> transformer
module Control.Monad.Trans.Rescue.Types

-- | Add type-directed error handling abilities to a <a>Monad</a>
newtype RescueT errs m a
RescueT :: m (Either (OpenUnion errs) a) -> RescueT errs m a
[runRescueT] :: RescueT errs m a -> m (Either (OpenUnion errs) a)

-- | A specialized version of <a>RescueT</a> to be used without a
--   transfromer stack
type Rescue errs = RescueT errs Identity
runRescue :: Rescue errs a -> Either (OpenUnion errs) a
instance GHC.Classes.Eq (m (Data.Either.Either (Data.WorldPeace.Union.OpenUnion errs) a)) => GHC.Classes.Eq (Control.Monad.Trans.Rescue.Types.RescueT errs m a)
instance GHC.Show.Show (m (Data.Either.Either (Data.WorldPeace.Union.OpenUnion errs) a)) => GHC.Show.Show (Control.Monad.Trans.Rescue.Types.RescueT errs m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Rescue.Types.RescueT errs)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance (GHC.Base.Monad m, Data.Traversable.Traversable m) => Data.Traversable.Traversable (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance GHC.Base.Monad m => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance (GHC.Base.Monad m, Control.Monad.Base.MonadBase n m) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Rescue.Types.RescueT errs n) m
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Rescue.Types.RescueT errs m)
instance Control.Monad.Reader.Class.MonadReader cfg m => Control.Monad.Reader.Class.MonadReader cfg (Control.Monad.Trans.Rescue.Types.RescueT errs m)


-- | This module supplies a "pure" monad transformer that can be used for
--   adding <tt>MonadRescue</tt> behaviour to a transformer stack
module Control.Monad.Trans.Rescue

module Control.Monad.Cleanup.Class

-- | Safely work with resources when an asynchronous exception may be
--   thrown
class (m `Raises` SomeException, MonadRescueFrom m m) => MonadCleanup m
cleanup :: MonadCleanup m => m resource -> (resource -> ErrorCase m -> m _ig1) -> (resource -> m _ig2) -> (resource -> m a) -> m a


-- | Cleanly release resources and clean up contexts
module Control.Monad.Cleanup
retry :: MonadCleanup m => Natural -> m a -> m a

-- | Equivalent of <tt>finally</tt>
always :: MonadCleanup m => m a -> m b -> m a


-- | The <a>CleanupT</a> transformer for adding async exceptions to a stack
module Control.Monad.Trans.Cleanup.Types

-- | Adds <a>SomeException</a> to an exception stack, and thus <i>aware</i>
--   of async exceptions
newtype CleanupT m a
CleanupT :: m a -> CleanupT m a
[runCleanupT] :: CleanupT m a -> m a
type CleanupIO a = CleanupT IO a
instance GHC.Classes.Eq (m a) => GHC.Classes.Eq (Control.Monad.Trans.Cleanup.Types.CleanupT m a)
instance GHC.Show.Show (m a) => GHC.Show.Show (Control.Monad.Trans.Cleanup.Types.CleanupT m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Cleanup.Types.CleanupT f)
instance Data.Foldable.Foldable t => Data.Foldable.Foldable (Control.Monad.Trans.Cleanup.Types.CleanupT t)
instance Data.Traversable.Traversable t => Data.Traversable.Traversable (Control.Monad.Trans.Cleanup.Types.CleanupT t)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Monad.Trans.Cleanup.Types.CleanupT f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Control.Monad.Trans.Cleanup.Types.CleanupT f)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Cleanup.Types.CleanupT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance (Data.WorldPeace.Union.Contains (Control.Monad.Raise.Class.Errors m) (Control.Monad.Raise.Class.Errors m), Control.Monad.Raise.Class.MonadRaise m, Control.Monad.Catch.MonadThrow m) => Control.Monad.Raise.Class.MonadRaise (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance Control.Monad.Base.MonadBase m m => Control.Monad.Base.MonadBase m (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance (GHC.Base.Monad m, Control.Monad.Rescue.Constraint.MonadRescue m) => Control.Monad.Rescue.Class.MonadRescueFrom m (Control.Monad.Trans.Cleanup.Types.CleanupT m)
instance (Control.Monad.Rescue.Class.MonadRescueFrom n m, Control.Monad.Base.MonadBase n m, Control.Monad.Rescue.Constraint.MonadRescue n, Control.Monad.Catch.MonadCatch n, Data.WorldPeace.Union.Contains (Control.Monad.Raise.Class.Errors n) (Control.Monad.Raise.Class.Errors n), Data.WorldPeace.Union.Contains (Control.Monad.Raise.Class.Errors n) (GHC.Exception.Type.SomeException : Control.Monad.Raise.Class.Errors n)) => Control.Monad.Rescue.Class.MonadRescueFrom (Control.Monad.Trans.Cleanup.Types.CleanupT n) m
instance (Data.WorldPeace.Union.Contains (Control.Monad.Raise.Class.Errors m) (Control.Monad.Raise.Class.Errors m), Data.WorldPeace.Union.Contains (Control.Monad.Raise.Class.Errors m) (GHC.Exception.Type.SomeException : Control.Monad.Raise.Class.Errors m), Control.Monad.Base.MonadBase m m, Control.Monad.Rescue.Constraint.MonadRescue m, Control.Monad.Catch.MonadMask m) => Control.Monad.Cleanup.Class.MonadCleanup (Control.Monad.Trans.Cleanup.Types.CleanupT m)

module Control.Monad.Trans.Cleanup
